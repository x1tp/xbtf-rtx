# Economy Concept

- Goals
  - Create a living supply/demand simulation driven by production cycles
  - Support race-specific resource chains and regional scarcity
  - Enable emergent gameplay: trade runs, shortages, booms, pirate disruption

- Entities
  - Wares: primary, food, intermediates, hi-tech, weapons, shields, missiles
  - Stations: producers and consumers with production recipes
  - Fleets: NPC and player ships executing logistics (buy, sell, deliver)
  - Sectors: nodes with local inventories and price signals

- Ware Categories
  - Primary: Energy Cells, Ore, Silicon Wafers, Teladianium, Warheads, Delexian Wheat
  - Food: Meatsteak Cahoonas, BoFu, Soja Husk, Rastar Oil, Nostrop Oil, Plankton, Scruffin Fruits, Stott Spices, Maja Snails, Sunrise Flower, Swamp Plants
  - Intermediates: Crystals, Quantum Tubes, Microchips, Computer Components, Cloth Rimes, Majaglit
  - End-products: Weapons (IRE/PAC/HEPT), Shields (1/5/25 MW), Missiles (Mosquito/Wasp/Dragonfly/Silkworm/Hornet), Space Fuel, Spaceweed

- Production Model
  - Each station defines: product ware, input wares, cycle time, batch size, storage caps
  - Cycle runs when inputs available; outputs added to inventory; inputs consumed
  - Race variants swap food/intermediate inputs per known recipes

- Prices and Signals
  - Base price per ware; dynamic modifier from local stock vs target stock
  - Price elasticity: steeper for end-products, moderate for intermediates, low for primaries
  - Buy threshold: stations buy inputs when local stock < reorder level
  - Sell threshold: stations sell outputs when local stock > reserve level

- Logistics and Flow
  - Market orders: generated by stations (buy inputs, sell outputs)
  - Order book per sector; orders matched to fleets via simple heuristic
  - NPC traders: prioritize highest margin routes within range and capacity
  - Player traders: same system, route planning UI reads order book

- Sectors and Connectivity
  - Graph of sectors with gates (edges) and travel times
  - Transport cost = distance factor × cargo volume × hazard factor
  - Hazards alter effective throughput; piracy increases loss rate and insurance premium

- Scarcity and Events
  - Global/sector events: shortages (e.g., Crystal drought), surpluses, embargo, war, pirate raids
  - Event impacts: temporarily adjust production rates, demand multipliers, risk

- Docks and Black Market
  - Equipment docks consume money, not inputs; act as sinks for end-products at capped rates
  - Pirate bases offer buy/sell for contraband with price premiums and risk modifiers

- Player Interaction
  - Build stations: add producers/consumers, configure price ranges and reserved stock
  - Trade automation: station-owned freighters and player scripts consume order book
  - Missions: fulfill bulk contracts, emergency deliveries, blockade running

- Balancing Levers
  - Cycle times, batch sizes, storage caps, reorder levels, price bands
  - NPC fleet density, route efficiency, event frequency, hazard strength

- Simulation Tick
  - Fixed tick (e.g., 10s): update station cycles, prices, generate orders
  - Every tick: match orders, move cargo, apply travel time, resolve losses
  - Price recompute: P = base × f(stock/target, recent_flow, event_mod)

- Data Structures (suggested)
  - Ware: id, basePrice, category, volume
  - Recipe: productId, inputs[{wareId, qty}], cycleTime, batchSize
  - Station: id, recipeId, inventory{wareId→qty}, caps, reorder/reserve, race, sectorId
  - Sector: id, neighbors, risk, orderBook
  - Order: type(buy/sell), stationId, wareId, qty, limitPrice, ttl
  - Fleet: id, capacity, speed, homeSector, behavior

- Algorithm Sketch
  - For each station: if inputs ≥ recipe requirements then run cycle; update inventories
  - For each station: ensure orders exist to acquire inputs up to reorder target; list outputs if above reserve
  - Price per ware per sector: base × (1 + k × shortageRatio − m × surplusRatio) clamped to bands
  - Route selection: score = (sellPrice − buyPrice − transportCost) × min(qty, capacity)

- Persistence
  - Save: station inventories, orders, sector prices, fleet assignments, event state
  - Load: rebuild order books and recompute live prices from inventories

- Roadmap
  - Phase 1: static recipes and tick-based production in one sector; manual trading
  - Phase 2: dynamic prices, multi-sector logistics, NPC traders
  - Phase 3: events, hazards, contraband, equipment dock sinks
  - Phase 4: player automation, station building, balance polish

- Data Model (TypeScript)
```ts
type WareCategory = 'primary' | 'food' | 'intermediate' | 'end'

interface Ware {
  id: string
  name: string
  category: WareCategory
  basePrice: number
  volume: number
}

interface RecipeInput {
  wareId: string
  amount: number
}

interface Recipe {
  id: string
  productId: string
  inputs: RecipeInput[]
  cycleTimeSec: number
  batchSize: number
  productStorageCap: number
  inputStorageCaps?: Record<string, number>
  race?: 'argon' | 'boron' | 'paranid' | 'split' | 'teladi' | 'pirate'
}

interface Station {
  id: string
  name: string
  recipeId: string
  sectorId: string
  inventory: Record<string, number>
  reorderLevel: Record<string, number>
  reserveLevel: Record<string, number>
  priceBands?: Record<string, { min: number; max: number }>
}

interface Sector {
  id: string
  name: string
  neighbors: string[]
  risk: number
}

interface Order {
  id: string
  type: 'buy' | 'sell'
  stationId: string
  wareId: string
  qty: number
  limitPrice: number
  ttlTicks: number
}

interface Fleet {
  id: string
  capacity: number
  speed: number
  homeSector: string
  behavior: 'npc' | 'player'
  cargo: Record<string, number>
  assignedOrderId?: string
}
```

- Price Function
  - P(s,w) = basePrice(w) × clamp(1 + α × shortage(s,w) + β × flow(s,w) + γ × event(s,w), bandMin(w), bandMax(w))
  - shortage(s,w) = (targetStock(w) − stock(s,w)) / max(targetStock(w), 1)
  - flow(s,w) = (recentDemand(w) − recentSupply(w)) / flowNorm(w)
  - α, β, γ tuned per category

- Order Generation
  - For each station input ware, if stock < reorderLevel, create buy order up to target
  - For station product ware, if stock > reserveLevel, create sell order for surplus
  - Orders carry limitPrice from current sector price

- Matching and Routing
  - Match buy and sell orders across connected sectors
  - Route score = (sellPrice − buyPrice − transportCost) × min(qty, capacity)
  - transportCost = distanceFactor × volume × hazardFactor
  - Assign fleets to highest score routes within range

- Tick Pseudocode
```ts
function tick(state: State) {
  for (const station of state.stations) {
    const r = state.recipes[station.recipeId]
    const canRun = r.inputs.every(x => (station.inventory[x.wareId] || 0) >= x.amount)
    if (canRun) {
      for (const x of r.inputs) station.inventory[x.wareId] -= x.amount
      station.inventory[r.productId] = (station.inventory[r.productId] || 0) + r.batchSize
    }
  }

  for (const station of state.stations) {
    const r = state.recipes[station.recipeId]
    for (const x of r.inputs) {
      const stock = station.inventory[x.wareId] || 0
      const rl = station.reorderLevel[x.wareId] || 0
      if (stock < rl) createBuyOrder(state, station, x.wareId, rl - stock)
    }
    const prodStock = station.inventory[r.productId] || 0
    const reserve = station.reserveLevel[r.productId] || 0
    if (prodStock > reserve) createSellOrder(state, station, r.productId, prodStock - reserve)
  }

  recomputePrices(state)
  matchOrdersAndAssignFleets(state)
  advanceShipMovements(state)
  resolveLossesAndDeliveries(state)
}
```

- Examples (JSON)
```json
{
  "wares": [
    { "id": "energy_cells", "name": "Energy Cells", "category": "primary", "basePrice": 16, "volume": 1 },
    { "id": "crystals", "name": "Crystals", "category": "intermediate", "basePrice": 1684, "volume": 1 },
    { "id": "meatsteak", "name": "Meatsteak Cahoonas", "category": "food", "basePrice": 72, "volume": 1 }
  ],
  "recipes": [
    {
      "id": "spp_argon",
      "productId": "energy_cells",
      "inputs": [ { "wareId": "crystals", "amount": 1 } ],
      "cycleTimeSec": 60,
      "batchSize": 10,
      "productStorageCap": 5000
    },
    {
      "id": "cahoona_bakery",
      "productId": "meatsteak",
      "inputs": [
        { "wareId": "energy_cells", "amount": 15 },
        { "wareId": "delexian_wheat", "amount": 20 },
        { "wareId": "argnu_beef", "amount": 6 },
        { "wareId": "stott_spices", "amount": 6 }
      ],
      "cycleTimeSec": 120,
      "batchSize": 30,
      "productStorageCap": 10000
    }
  ],
  "stations": [
    {
      "id": "argon_spp_01",
      "name": "Solar Power Plant",
      "recipeId": "spp_argon",
      "sectorId": "argon_prime",
      "inventory": { "energy_cells": 0, "crystals": 10 },
      "reorderLevel": { "crystals": 5 },
      "reserveLevel": { "energy_cells": 100 }
    }
  ]
}
```
